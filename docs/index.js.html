<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-leaf-detective_main.Biases.html">Biases</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Biases.html#fillRandom">fillRandom</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Biases.html#populate">populate</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-leaf-detective_main.Layer.html">Layer</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Layer.html#addBiases">addBiases</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Layer.html#addWeights">addWeights</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Layer.html#apply">apply</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Layer.html#connect">connect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Layer.html#populate">populate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Layer.html#run">run</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-leaf-detective_main.Network.html">Network</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Network.html#addBiases">addBiases</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Network.html#addWeights">addWeights</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Network.html#backpropagate">backpropagate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Network.html#calculateDeltas">calculateDeltas</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Network.html#connect">connect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Network.html#populate">populate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Network.html#run">run</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-leaf-detective_main.Weights.html">Weights</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Weights.html#fillRandom">fillRandom</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_main.Weights.html#populate">populate</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-leaf-detective_helpers.html">leaf-detective/helpers</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_helpers.html#.plus">plus</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_helpers.html#.sigmoid">sigmoid</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-leaf-detective_helpers.html#.squaredError">squaredError</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-leaf-detective_main.html">leaf-detective/main</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module leaf-detective/main */

import { plus, squaredError } from "./helpers.js";

/**
 * Class representing layer weights
 * @extends Array
 */
export class Weights extends Array {
    /**
     * Creates weights matrix
     * @param {Number} width width of weights matrix
     * @param {Number} height height of weights matrix
     */
    constructor(width, height) {
        super(height)
            .fill(0)
            .forEach((_, i, arr) => (arr[i] = new Array(width).fill(0)));
    }

    /**
     * Fills weights matrix with random numbers between 0 (included) and 1
     * (excluded)
     * @returns {Weights}
     */
    fillRandom() {
        return this.map(row => row.map(_ => Math.random()));
    }

    /**
     * Fills given data into matrix
     * @param {Array} data array of data to populate weights matrix with; must
     * be of same width and height as matrix
     * @returns {Weights}
     */
    populate(data) {
        return this.map((row, i) => row.map((_, j) => data[i][j]));
    }
}

/**
 * Class representing layer biases
 * @extends Array
 */
export class Biases extends Array {
    /**
     * Creates a bias matrix
     * @param {Number} height height of bias matrix; must correspond to output
     * layers length
     */
    constructor(height) {
        super(height).fill(0);
    }

    /**
     * Fills bias matrix with random numbers between -1 (included) and 1
     * (excluded)
     * @returns {Biases}
     */
    fillRandom() {
        return this.map(_ => Math.random() * 2 - 1);
    }

    /**
     * Fills given data into matrix
     * @param {Array} data array of data to populate bias matrix with; must be
     * same width as matrix
     * @returns {Biases}
     */
    populate(data) {
        return this.map((_, i) => data[i]);
    }
}

/**
 * Class representing layer matrix
 * @example
 * // Import constructors and helpers
 * import { Layer, Weights, Biases } from "./index.js";
 * import { sigmoid } from "./helpers.js";
 *
 * // Create Layers
 * let inputLayer = new Layer(5);
 * let outputLayer = new Layer(2);
 *
 * // Create weights and biases
 * let weights = new Weights(inputLayer.length, outputLayer.length).fillRandom();
 * let biases = new Biases(outputLayer.length).populate([-10, 10]);
 *
 * // Connect weights and outputLayer to inputLayer
 * inputLayer.addWeights(weights).connect(outputLayer);
 * // Connect biases to outputLayer
 * outputLayer.addBiases(biases);
 *
 * // Add data and run neural net
 * inputLayer.populate([1, 1, 1, 1, 1]).run().apply(sigmoid);
 */
export class Layer {
    /**
     * Creates a layer with given amount of neurons
     * @param {Number} length length / amount of neurons of layer
     */
    constructor(length) {
        this.neurons = new Array(length).fill(0);
        this.length = length;

        this.weights = null;
        this.biases = null;

        this.next = null;
        this.previous = null;
    }

    /**
     * Adds Biases object to layer
     * @param {Biases} biases biases object from Biases constructor; belongs to
     * ouput layer
     * @example
     * let inputLayer = new Layer(5);
     * let outputLayer = new Layer(2);
     *
     * outputLayer.addBiases(biases);
     * @returns {Layer}
     */
    addBiases(biases) {
        if (!(biases instanceof Biases))
            throw new Error("Please pass a bias object");
        this.biases = biases;
        return this;
    }

    /**
     * Adds Weights object to layer
     * @param {Weights} weights weights object from Weights constructor; belongs
     * to input layer
     * @example
     * let inputLayer = new Layer(5);
     * let outputLayer = new Layer(2);
     *
     * inputLayer.addWeights(weights);
     * @returns {Layer}
     */
    addWeights(weights) {
        if (!(weights instanceof Weights))
            throw new Error("Please pass a weights object");
        else if (!weights.every(row => row.length === this.length))
            throw new Error(
                "Width of weight matrix must be equal to amount of neurons"
            );
        this.weights = weights;
        return this;
    }

    /**
     * Applys given activation function to all neurons of the layer
     * @param {Function} activation mapping activation function called with
     * neuron value an index
     * @example
     * outputLayer.apply(sigmoid);
     * @returns {Layer}
     */
    apply(activation) {
        this.neurons = this.neurons.map((neuron, i) => activation(neuron, i));
        return this;
    }

    /**
     * Connects an input layer with an output layer
     * @param {Layer} layer output layer object
     * @example
     * let inputLayer = new Layer(5);
     * let outputLayer = new Layer(2);
     *
     * inputLayer.connect(outputLayer)
     * @returns {Layer}
     */
    connect(layer) {
        if (!(layer instanceof Layer)) throw new Error("Please pass a layer");
        this.next = layer;
        layer.previous = this;
        return this;
    }

    /**
     * Populates neurons with data
     * @param {Array} data array of data to populate layer / neurons with; must
     * be same length as layer
     * @returns {Layer}
     */
    populate(data) {
        if (data.length !== this.length)
            throw new Error(
                `Please pass data of length ${this.neurons.length}`
            );
        this.neurons = [...data];
        return this;
    }

    /**
     * Runs connection between two layers by applying weights to input layer's
     * neurons and biases to resulting output layer's neurons
     * @example
     * let inputLayer = new Layer(5);
     * let outputLayer = new Layer(2);
     *
     * inputLayer.connect(outputLayer).run()
     * @returns {Layer} connected output layer
     */
    run() {
        this.next.neurons = this.next.neurons
            .map((_, row) =>
                this.neurons
                    .map((neuron, col) => neuron * this.weights[row][col])
                    .reduce(plus, 0)
            )
            .map((output, row) => output + this.next.biases[row]);
        return this.next;
    }
}

/**
 * Neural Network Class
 * @extends Array
 * @example
 * // Import Constructors and helpers
 * import { Network, Layer, Weights, Biases } from "./index.js";
 * import { sigmoid } from "./helpers.js";
 *
 * // Create network
 * let network = new Network([2048, 1024, 512, 256]);
 * // Run network
 * network
 *   .addWeights()
 *   .addBiases()
 *   .connect()
 *   .run(sigmoid)
 */
export class Network extends Array {
    /**
     * Creates a neural network with given layers
     * @param {Array} layers array of Layer objects or numbers representing
     * layer length
     */
    constructor(layers) {
        super(...layers.map(el => (el instanceof Layer ? el : new Layer(el))));
    }

    /**
     * Adds randomly filled bias matrix with correct dimensions to every layer
     * by calling Biases constructor
     * @returns {Network}
     */
    addBiases() {
        this.forEach((layer, i) => {
            if (i > 0) {
                layer.addBiases(new Biases(layer.length).fillRandom());
            }
        });
        return this;
    }

    /**
     * Adds randomly filled weight matrix with correct dimensions to every layer
     * by calling Weights constructor
     * @returns {Network}
     */
    addWeights() {
        this.forEach((layer, i) => {
            if (i &lt; this.length - 1) {
                layer.addWeights(
                    new Weights(layer.length, this[i + 1].length).fillRandom()
                );
            }
        });
        return this;
    }

    /**
     * Connects every layers with its succedding layer by calling layer.connect
     * @returns {Network}
     */
    connect() {
        this.forEach((layer, i) =>
            i &lt; this.length - 1 ? layer.connect(this[i + 1]) : ""
        );
        return this;
    }

    /**
     * Runs the neural network and optionally applies a activation function
     * @param {Function} [activation=false] activation function
     * @returns {Network}
     */
    run(activation = false) {
        this.forEach(
            layer =>
                layer.next &amp;&amp;
                layer.run() &amp;&amp;
                activation &amp;&amp;
                layer.next.apply(activation)
        );
        return this;
    }

    /**
     * Backpropagate input and adjust weights based on error
     * @param {Array} targets targets for the current dataset; must be as long
     * as output layer
     * @param {Number} [learningRate=0.5] learning rate; must be between 0 (excluded)
     * and 1 (included)
     * @param {Number} [momentum=Math.random()] momentum; must be between 0 (included) and 1
     * (excluded)
     * @example
     * network
     *     .run(sigmoid)
     *     .backpropagate([1, 0]);
     * @returns {Network}
     */
    backpropagate(targets, learningRate = 0.5, momentum = Math.random()) {
        let deltas = this.calculateDeltas(targets);

        for (let currLayer = 0; currLayer &lt; this.length - 1; currLayer++) {
            const layer = this[currLayer];

            layer.weights = layer.weights.map((weightsRow, output) =>
                weightsRow.map(
                    (weight, input) =>
                        learningRate *
                            deltas[currLayer + 1][output] *
                            layer.neurons[input] +
                        momentum * weight
                )
            );
        }

        return this;
    }

    /**
     * Calculate deltas / "error term" for output layers and hidden layers
     * @param {Array} targets targets for the current dataset; must be as long
     * as output layer
     * @returns {Array} array of delta-arrays with the width of the Network - 1
     * (every layer except input layer); every delta-array has the height of the
     * corresponding layer (number of neurons in that layer)
     */
    calculateDeltas(targets) {
        let deltas = new Array(this.length)
            .fill(0)
            .map((_, layer) => new Array(this[layer].length).fill(0));

        for (let currLayer = this.length - 1; currLayer > 0; currLayer--) {
            const layer = this[currLayer].neurons;

            deltas[currLayer] = deltas[currLayer].map((_, currNeuron) => {
                // Calculate delta for output layer
                if (currLayer === this.length - 1) {
                    return (
                        (targets[currNeuron] - layer[currNeuron]) *
                        layer[currNeuron] *
                        (1 - layer[currNeuron])
                    );
                }
                // Calculate delta for hidden layer
                else {
                    const previousLayer = this[currLayer + 1].neurons;

                    return (
                        previousLayer
                            .map(
                                (_, index) =>
                                    deltas[currLayer + 1][index] *
                                    this[currLayer].weights[index][currNeuron]
                            )
                            .reduce(plus, 0) *
                        layer[currNeuron] *
                        (1 - layer[currNeuron])
                    );
                }
            });
        }

        return deltas;
    }

    /**
     * Populates input layer with data
     * @param {Array} data array of data to populate input layer with; must be
     * same length as layer
     * @returns {Network}
     */
    populate(data) {
        this[0].populate(data);
        return this;
    }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a> on Mon Jul 08 2019 16:24:27 GMT+0200 (Central European Summer Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
